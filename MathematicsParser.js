window.PARSER = /*
		 * Generated by PEG.js 0.10.0.
		 *
		 * http://pegjs.org/
		 */
(function() {
    "use strict";

    function peg$subclass(child, parent) {
	function ctor() { this.constructor = child; }
	ctor.prototype = parent.prototype;
	child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
	this.message  = message;
	this.expected = expected;
	this.found    = found;
	this.location = location;
	this.name     = "SyntaxError";
	
	if (typeof Error.captureStackTrace === "function") {
	    Error.captureStackTrace(this, peg$SyntaxError);
	}
    }

    peg$subclass(peg$SyntaxError, Error);
    
    peg$SyntaxError.buildMessage = function(expected, found) {
	var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
		return "\"" + literalEscape(expectation.text) + "\"";
            },
	    
            "class": function(expectation) {
		var escapedParts = "",
                    i;
		
		for (i = 0; i < expectation.parts.length; i++) {
		    escapedParts += expectation.parts[i] instanceof Array
			? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
			: classEscape(expectation.parts[i]);
		}

		return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
            },
	    
            any: function(expectation) {
		return "any character";
            },
	    
            end: function(expectation) {
		return "end of input";
            },
	    
            other: function(expectation) {
		return expectation.description;
            }
        };
	
	function hex(ch) {
	    return ch.charCodeAt(0).toString(16).toUpperCase();
	}
	
	function literalEscape(s) {
	    return s
		.replace(/\\/g, '\\\\')
		.replace(/"/g,  '\\"')
		.replace(/\0/g, '\\0')
		.replace(/\t/g, '\\t')
		.replace(/\n/g, '\\n')
		.replace(/\r/g, '\\r')
		.replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
		.replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
	}
	
	function classEscape(s) {
	    return s
		.replace(/\\/g, '\\\\')
		.replace(/\]/g, '\\]')
		.replace(/\^/g, '\\^')
		.replace(/-/g,  '\\-')
		.replace(/\0/g, '\\0')
		.replace(/\t/g, '\\t')
		.replace(/\n/g, '\\n')
		.replace(/\r/g, '\\r')
		.replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
		.replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
	}
	
	function describeExpectation(expectation) {
	    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
	}
	
	function describeExpected(expected) {
	    var descriptions = new Array(expected.length),
		i, j;
	    
	    for (i = 0; i < expected.length; i++) {
		descriptions[i] = describeExpectation(expected[i]);
	    }
	    
	    descriptions.sort();
	    
	    if (descriptions.length > 0) {
		for (i = 1, j = 1; i < descriptions.length; i++) {
		    if (descriptions[i - 1] !== descriptions[i]) {
			descriptions[j] = descriptions[i];
			j++;
		    }
		}
		descriptions.length = j;
	    }
	    
	    switch (descriptions.length) {
            case 1:
		return descriptions[0];
		
            case 2:
		return descriptions[0] + " or " + descriptions[1];
		
            default:
		return descriptions.slice(0, -1).join(", ")
		    + ", or "
		    + descriptions[descriptions.length - 1];
	    }
	}
	
	function describeFound(found) {
	    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
	}
	
	return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    
    function peg$parse(input, options) {
	options = options !== void 0 ? options : {};
	
	var peg$FAILED = {},
	    
            peg$startRuleFunctions = { Expression: peg$parseExpression },
            peg$startRuleFunction  = peg$parseExpression,
	    
            peg$c0 = "+",
            peg$c1 = peg$literalExpectation("+", false),
            peg$c2 = "-",
            peg$c3 = peg$literalExpectation("-", false),
            peg$c4 = function(head, tail) { 
		return tail.reduce(function(result, element) {
                    if (element[1] === "+") { return result.add(element[3]); }
                    if (element[1] === "-") { return result.add(element[3].negate()); }
		}, new Expression(head)); },
            peg$c5 = "*",
            peg$c6 = peg$literalExpectation("*", false),
            peg$c7 = "/",
            peg$c8 = peg$literalExpectation("/", false),
            peg$c9 = function(head, tail) { 
		return tail.reduce(function(result, element) {
		    //       console.log("element="+element+" array="+Array.isArray(element));
                    if(element.constructor.name == Factor.name) { return result.multiply(element); }	 
                    else if (element[1][0] === "*" ) { return result.multiply(element[1][2]); }
                    else if (element[1][0] === "/") { element[1][2].index.item=element[1][2].index.item.negate();
						      return result.multiply(element[1][2]); }
		}, new Term(head)); },
            peg$c10 = function(t) { return t.negate(); },
            peg$c11 = "^",
            peg$c12 = peg$literalExpectation("^", false),
            peg$c13 = function(atom, index) { return new Factor(atom, index); },
            peg$c14 = function(atom, index) { return new Factor(atom, new Atom(index)); },
            peg$c15 = function(atom) { return new Factor(atom, new Atom(1)); },
            peg$c16 = "(",
            peg$c17 = peg$literalExpectation("(", false),
            peg$c18 = ")",
            peg$c19 = peg$literalExpectation(")", false),
            peg$c20 = function(expr) { return new Atom(expr); },
            peg$c21 = function(pro) { return new Atom(pro); },
            peg$c22 = function(dec) { return new Atom(dec); },
            peg$c23 = /^[0-9]/,
            peg$c24 = peg$classExpectation([["0", "9"]], false, false),
            peg$c25 = ".",
            peg$c26 = peg$literalExpectation(".", false),
            peg$c27 = function(whole, part) {  return makeFloat(whole,part); },
            peg$c28 = function(whole) { return makeInt(whole); },
            peg$c29 = function(dec) {  return dec; },
            peg$c30 = function(dec) { return dec.negate(); },
            peg$c31 = function(int) { return int; },
            peg$c32 = function(whole) { return makeInt(whole).negate(); },
            peg$c33 = function(atom) { return new Atom(expr); },
            peg$c34 = /^[a-zA-Z_]/,
            peg$c35 = peg$classExpectation([["a", "z"], ["A", "Z"], "_"], false, false),
            peg$c36 = peg$otherExpectation("whitespace"),
            peg$c37 = /^[ \t\n\r]/,
            peg$c38 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),

            peg$currPos          = 0,
            peg$savedPos         = 0,
            peg$posDetailsCache  = [{ line: 1, column: 1 }],
            peg$maxFailPos       = 0,
            peg$maxFailExpected  = [],
            peg$silentFails      = 0,

            peg$result;

	if ("startRule" in options) {
	    if (!(options.startRule in peg$startRuleFunctions)) {
		throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	    }

	    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	}

	function text() {
	    return input.substring(peg$savedPos, peg$currPos);
	}

	function location() {
	    return peg$computeLocation(peg$savedPos, peg$currPos);
	}

	function expected(description, location) {
	    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

	    throw peg$buildStructuredError(
		[peg$otherExpectation(description)],
		input.substring(peg$savedPos, peg$currPos),
		location
	    );
	}

	function error(message, location) {
	    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

	    throw peg$buildSimpleError(message, location);
	}

	function peg$literalExpectation(text, ignoreCase) {
	    return { type: "literal", text: text, ignoreCase: ignoreCase };
	}

	function peg$classExpectation(parts, inverted, ignoreCase) {
	    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
	}

	function peg$anyExpectation() {
	    return { type: "any" };
	}

	function peg$endExpectation() {
	    return { type: "end" };
	}

	function peg$otherExpectation(description) {
	    return { type: "other", description: description };
	}

	function peg$computePosDetails(pos) {
	    var details = peg$posDetailsCache[pos], p;

	    if (details) {
		return details;
	    } else {
		p = pos - 1;
		while (!peg$posDetailsCache[p]) {
		    p--;
		}

		details = peg$posDetailsCache[p];
		details = {
		    line:   details.line,
		    column: details.column
		};

		while (p < pos) {
		    if (input.charCodeAt(p) === 10) {
			details.line++;
			details.column = 1;
		    } else {
			details.column++;
		    }

		    p++;
		}

		peg$posDetailsCache[pos] = details;
		return details;
	    }
	}

	function peg$computeLocation(startPos, endPos) {
	    var startPosDetails = peg$computePosDetails(startPos),
		endPosDetails   = peg$computePosDetails(endPos);

	    return {
		start: {
		    offset: startPos,
		    line:   startPosDetails.line,
		    column: startPosDetails.column
		},
		end: {
		    offset: endPos,
		    line:   endPosDetails.line,
		    column: endPosDetails.column
		}
	    };
	}

	function peg$fail(expected) {
	    if (peg$currPos < peg$maxFailPos) { return; }

	    if (peg$currPos > peg$maxFailPos) {
		peg$maxFailPos = peg$currPos;
		peg$maxFailExpected = [];
	    }

	    peg$maxFailExpected.push(expected);
	}

	function peg$buildSimpleError(message, location) {
	    return new peg$SyntaxError(message, null, null, location);
	}

	function peg$buildStructuredError(expected, found, location) {
	    return new peg$SyntaxError(
		peg$SyntaxError.buildMessage(expected, found),
		expected,
		found,
		location
	    );
	}

	function peg$parseExpression() {
	    var s0, s1, s2, s3, s4, s5, s6, s7;

	    s0 = peg$currPos;
	    s1 = peg$parseTerm();
	    if (s1 !== peg$FAILED) {
		s2 = [];
		s3 = peg$currPos;
		s4 = peg$parse_();
		if (s4 !== peg$FAILED) {
		    if (input.charCodeAt(peg$currPos) === 43) {
			s5 = peg$c0;
			peg$currPos++;
		    } else {
			s5 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c1); }
		    }
		    if (s5 === peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 45) {
			    s5 = peg$c2;
			    peg$currPos++;
			} else {
			    s5 = peg$FAILED;
			    if (peg$silentFails === 0) { peg$fail(peg$c3); }
			}
		    }
		    if (s5 !== peg$FAILED) {
			s6 = peg$parse_();
			if (s6 !== peg$FAILED) {
			    s7 = peg$parseTerm();
			    if (s7 !== peg$FAILED) {
				s4 = [s4, s5, s6, s7];
				s3 = s4;
			    } else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			    }
			} else {
			    peg$currPos = s3;
			    s3 = peg$FAILED;
			}
		    } else {
			peg$currPos = s3;
			s3 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s3;
		    s3 = peg$FAILED;
		}
		while (s3 !== peg$FAILED) {
		    s2.push(s3);
		    s3 = peg$currPos;
		    s4 = peg$parse_();
		    if (s4 !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 43) {
			    s5 = peg$c0;
			    peg$currPos++;
			} else {
			    s5 = peg$FAILED;
			    if (peg$silentFails === 0) { peg$fail(peg$c1); }
			}
			if (s5 === peg$FAILED) {
			    if (input.charCodeAt(peg$currPos) === 45) {
				s5 = peg$c2;
				peg$currPos++;
			    } else {
				s5 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c3); }
			    }
			}
			if (s5 !== peg$FAILED) {
			    s6 = peg$parse_();
			    if (s6 !== peg$FAILED) {
				s7 = peg$parseTerm();
				if (s7 !== peg$FAILED) {
				    s4 = [s4, s5, s6, s7];
				    s3 = s4;
				} else {
				    peg$currPos = s3;
				    s3 = peg$FAILED;
				}
			    } else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			    }
			} else {
			    peg$currPos = s3;
			    s3 = peg$FAILED;
			}
		    } else {
			peg$currPos = s3;
			s3 = peg$FAILED;
		    }
		}
		if (s2 !== peg$FAILED) {
		    peg$savedPos = s0;
		    s1 = peg$c4(s1, s2);
		    s0 = s1;
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
	    } else {
		peg$currPos = s0;
		s0 = peg$FAILED;
	    }

	    return s0;
	}

	function peg$parseTerm() {
	    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

	    s0 = peg$currPos;
	    s1 = peg$parseFactor();
	    if (s1 !== peg$FAILED) {
		s2 = [];
		s3 = peg$currPos;
		s4 = peg$parse_();
		if (s4 !== peg$FAILED) {
		    s5 = peg$currPos;
		    if (input.charCodeAt(peg$currPos) === 42) {
			s6 = peg$c5;
			peg$currPos++;
		    } else {
			s6 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c6); }
		    }
		    if (s6 === peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 47) {
			    s6 = peg$c7;
			    peg$currPos++;
			} else {
			    s6 = peg$FAILED;
			    if (peg$silentFails === 0) { peg$fail(peg$c8); }
			}
		    }
		    if (s6 !== peg$FAILED) {
			s7 = peg$parse_();
			if (s7 !== peg$FAILED) {
			    s8 = peg$parseFactor();
			    if (s8 !== peg$FAILED) {
				s6 = [s6, s7, s8];
				s5 = s6;
			    } else {
				peg$currPos = s5;
				s5 = peg$FAILED;
			    }
			} else {
			    peg$currPos = s5;
			    s5 = peg$FAILED;
			}
		    } else {
			peg$currPos = s5;
			s5 = peg$FAILED;
		    }
		    if (s5 !== peg$FAILED) {
			s4 = [s4, s5];
			s3 = s4;
		    } else {
			peg$currPos = s3;
			s3 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s3;
		    s3 = peg$FAILED;
		}
		if (s3 === peg$FAILED) {
		    s3 = peg$parseNonDigitFactor();
		}
		while (s3 !== peg$FAILED) {
		    s2.push(s3);
		    s3 = peg$currPos;
		    s4 = peg$parse_();
		    if (s4 !== peg$FAILED) {
			s5 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 42) {
			    s6 = peg$c5;
			    peg$currPos++;
			} else {
			    s6 = peg$FAILED;
			    if (peg$silentFails === 0) { peg$fail(peg$c6); }
			}
			if (s6 === peg$FAILED) {
			    if (input.charCodeAt(peg$currPos) === 47) {
				s6 = peg$c7;
				peg$currPos++;
			    } else {
				s6 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c8); }
			    }
			}
			if (s6 !== peg$FAILED) {
			    s7 = peg$parse_();
			    if (s7 !== peg$FAILED) {
				s8 = peg$parseFactor();
				if (s8 !== peg$FAILED) {
				    s6 = [s6, s7, s8];
				    s5 = s6;
				} else {
				    peg$currPos = s5;
				    s5 = peg$FAILED;
				}
			    } else {
				peg$currPos = s5;
				s5 = peg$FAILED;
			    }
			} else {
			    peg$currPos = s5;
			    s5 = peg$FAILED;
			}
			if (s5 !== peg$FAILED) {
			    s4 = [s4, s5];
			    s3 = s4;
			} else {
			    peg$currPos = s3;
			    s3 = peg$FAILED;
			}
		    } else {
			peg$currPos = s3;
			s3 = peg$FAILED;
		    }
		    if (s3 === peg$FAILED) {
			s3 = peg$parseNonDigitFactor();
		    }
		}
		if (s2 !== peg$FAILED) {
		    peg$savedPos = s0;
		    s1 = peg$c9(s1, s2);
		    s0 = s1;
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
	    } else {
		peg$currPos = s0;
		s0 = peg$FAILED;
	    }
	    if (s0 === peg$FAILED) {
		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 45) {
		    s1 = peg$c2;
		    peg$currPos++;
		} else {
		    s1 = peg$FAILED;
		    if (peg$silentFails === 0) { peg$fail(peg$c3); }
		}
		if (s1 !== peg$FAILED) {
		    s2 = peg$parseTerm();
		    if (s2 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c10(s2);
			s0 = s1;
		    } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
	    }

	    return s0;
	}

	function peg$parseFactor() {
	    var s0, s1, s2, s3, s4, s5;

	    s0 = peg$currPos;
	    s1 = peg$parseAtom();
	    if (s1 !== peg$FAILED) {
		s2 = peg$parse_();
		if (s2 !== peg$FAILED) {
		    if (input.charCodeAt(peg$currPos) === 94) {
			s3 = peg$c11;
			peg$currPos++;
		    } else {
			s3 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c12); }
		    }
		    if (s3 !== peg$FAILED) {
			s4 = peg$parse_();
			if (s4 !== peg$FAILED) {
			    s5 = peg$parseAtom();
			    if (s5 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c13(s1, s5);
				s0 = s1;
			    } else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			    }
			} else {
			    peg$currPos = s0;
			    s0 = peg$FAILED;
			}
		    } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
	    } else {
		peg$currPos = s0;
		s0 = peg$FAILED;
	    }
	    if (s0 === peg$FAILED) {
		s0 = peg$currPos;
		s1 = peg$parseAtom();
		if (s1 !== peg$FAILED) {
		    s2 = peg$parse_();
		    if (s2 !== peg$FAILED) {
			s3 = peg$parsePositiveDecimal();
			if (s3 !== peg$FAILED) {
			    peg$savedPos = s0;
			    s1 = peg$c14(s1, s3);
			    s0 = s1;
			} else {
			    peg$currPos = s0;
			    s0 = peg$FAILED;
			}
		    } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
		if (s0 === peg$FAILED) {
		    s0 = peg$currPos;
		    s1 = peg$parseAtom();
		    if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c15(s1);
		    }
		    s0 = s1;
		}
	    }

	    return s0;
	}

	function peg$parseNonDigitFactor() {
	    var s0, s1, s2, s3, s4, s5;

	    s0 = peg$currPos;
	    s1 = peg$parseNonDigitAtom();
	    if (s1 !== peg$FAILED) {
		s2 = peg$parse_();
		if (s2 !== peg$FAILED) {
		    if (input.charCodeAt(peg$currPos) === 94) {
			s3 = peg$c11;
			peg$currPos++;
		    } else {
			s3 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c12); }
		    }
		    if (s3 !== peg$FAILED) {
			s4 = peg$parse_();
			if (s4 !== peg$FAILED) {
			    s5 = peg$parseAtom();
			    if (s5 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c13(s1, s5);
				s0 = s1;
			    } else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			    }
			} else {
			    peg$currPos = s0;
			    s0 = peg$FAILED;
			}
		    } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
	    } else {
		peg$currPos = s0;
		s0 = peg$FAILED;
	    }
	    if (s0 === peg$FAILED) {
		s0 = peg$currPos;
		s1 = peg$parseNonDigitAtom();
		if (s1 !== peg$FAILED) {
		    s2 = peg$parse_();
		    if (s2 !== peg$FAILED) {
			s3 = peg$parsePositiveDecimal();
			if (s3 !== peg$FAILED) {
			    peg$savedPos = s0;
			    s1 = peg$c14(s1, s3);
			    s0 = s1;
			} else {
			    peg$currPos = s0;
			    s0 = peg$FAILED;
			}
		    } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
		if (s0 === peg$FAILED) {
		    s0 = peg$currPos;
		    s1 = peg$parseNonDigitAtom();
		    if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c15(s1);
		    }
		    s0 = s1;
		}
	    }

	    return s0;
	}

	function peg$parseNonDigitAtom() {
	    var s0, s1, s2, s3, s4, s5;

	    s0 = peg$currPos;
	    if (input.charCodeAt(peg$currPos) === 40) {
		s1 = peg$c16;
		peg$currPos++;
	    } else {
		s1 = peg$FAILED;
		if (peg$silentFails === 0) { peg$fail(peg$c17); }
	    }
	    if (s1 !== peg$FAILED) {
		s2 = peg$parse_();
		if (s2 !== peg$FAILED) {
		    s3 = peg$parseExpression();
		    if (s3 !== peg$FAILED) {
			s4 = peg$parse_();
			if (s4 !== peg$FAILED) {
			    if (input.charCodeAt(peg$currPos) === 41) {
				s5 = peg$c18;
				peg$currPos++;
			    } else {
				s5 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c19); }
			    }
			    if (s5 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c20(s3);
				s0 = s1;
			    } else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			    }
			} else {
			    peg$currPos = s0;
			    s0 = peg$FAILED;
			}
		    } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
	    } else {
		peg$currPos = s0;
		s0 = peg$FAILED;
	    }
	    if (s0 === peg$FAILED) {
		s0 = peg$currPos;
		s1 = peg$parsePronumeral();
		if (s1 !== peg$FAILED) {
		    peg$savedPos = s0;
		    s1 = peg$c21(s1);
		}
		s0 = s1;
	    }

	    return s0;
	}

	function peg$parseAtom() {
	    var s0, s1, s2, s3;

	    s0 = peg$currPos;
	    if (input.charCodeAt(peg$currPos) === 40) {
		s1 = peg$c16;
		peg$currPos++;
	    } else {
		s1 = peg$FAILED;
		if (peg$silentFails === 0) { peg$fail(peg$c17); }
	    }
	    if (s1 !== peg$FAILED) {
		s2 = peg$parseExpression();
		if (s2 !== peg$FAILED) {
		    if (input.charCodeAt(peg$currPos) === 41) {
			s3 = peg$c18;
			peg$currPos++;
		    } else {
			s3 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c19); }
		    }
		    if (s3 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c20(s2);
			s0 = s1;
		    } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
	    } else {
		peg$currPos = s0;
		s0 = peg$FAILED;
	    }
	    if (s0 === peg$FAILED) {
		s0 = peg$currPos;
		s1 = peg$parseDecimal();
		if (s1 !== peg$FAILED) {
		    peg$savedPos = s0;
		    s1 = peg$c22(s1);
		}
		s0 = s1;
		if (s0 === peg$FAILED) {
		    s0 = peg$currPos;
		    s1 = peg$parsePronumeral();
		    if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c21(s1);
		    }
		    s0 = s1;
		}
	    }

	    return s0;
	}

	function peg$parsePositiveDecimal() {
	    var s0, s1, s2, s3, s4;

	    s0 = peg$currPos;
	    s1 = [];
	    if (peg$c23.test(input.charAt(peg$currPos))) {
		s2 = input.charAt(peg$currPos);
		peg$currPos++;
	    } else {
		s2 = peg$FAILED;
		if (peg$silentFails === 0) { peg$fail(peg$c24); }
	    }
	    while (s2 !== peg$FAILED) {
		s1.push(s2);
		if (peg$c23.test(input.charAt(peg$currPos))) {
		    s2 = input.charAt(peg$currPos);
		    peg$currPos++;
		} else {
		    s2 = peg$FAILED;
		    if (peg$silentFails === 0) { peg$fail(peg$c24); }
		}
	    }
	    if (s1 !== peg$FAILED) {
		if (input.charCodeAt(peg$currPos) === 46) {
		    s2 = peg$c25;
		    peg$currPos++;
		} else {
		    s2 = peg$FAILED;
		    if (peg$silentFails === 0) { peg$fail(peg$c26); }
		}
		if (s2 !== peg$FAILED) {
		    s3 = [];
		    if (peg$c23.test(input.charAt(peg$currPos))) {
			s4 = input.charAt(peg$currPos);
			peg$currPos++;
		    } else {
			s4 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c24); }
		    }
		    if (s4 !== peg$FAILED) {
			while (s4 !== peg$FAILED) {
			    s3.push(s4);
			    if (peg$c23.test(input.charAt(peg$currPos))) {
				s4 = input.charAt(peg$currPos);
				peg$currPos++;
			    } else {
				s4 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c24); }
			    }
			}
		    } else {
			s3 = peg$FAILED;
		    }
		    if (s3 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c27(s1, s3);
			s0 = s1;
		    } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
	    } else {
		peg$currPos = s0;
		s0 = peg$FAILED;
	    }
	    if (s0 === peg$FAILED) {
		s0 = peg$currPos;
		s1 = [];
		if (peg$c23.test(input.charAt(peg$currPos))) {
		    s2 = input.charAt(peg$currPos);
		    peg$currPos++;
		} else {
		    s2 = peg$FAILED;
		    if (peg$silentFails === 0) { peg$fail(peg$c24); }
		}
		if (s2 !== peg$FAILED) {
		    while (s2 !== peg$FAILED) {
			s1.push(s2);
			if (peg$c23.test(input.charAt(peg$currPos))) {
			    s2 = input.charAt(peg$currPos);
			    peg$currPos++;
			} else {
			    s2 = peg$FAILED;
			    if (peg$silentFails === 0) { peg$fail(peg$c24); }
			}
		    }
		} else {
		    s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
		    peg$savedPos = s0;
		    s1 = peg$c28(s1);
		}
		s0 = s1;
	    }

	    return s0;
	}

	function peg$parseDecimal() {
	    var s0, s1, s2, s3;

	    s0 = peg$currPos;
	    s1 = peg$parsePositiveDecimal();
	    if (s1 !== peg$FAILED) {
		peg$savedPos = s0;
		s1 = peg$c29(s1);
	    }
	    s0 = s1;
	    if (s0 === peg$FAILED) {
		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 45) {
		    s1 = peg$c2;
		    peg$currPos++;
		} else {
		    s1 = peg$FAILED;
		    if (peg$silentFails === 0) { peg$fail(peg$c3); }
		}
		if (s1 !== peg$FAILED) {
		    s2 = peg$parse_();
		    if (s2 !== peg$FAILED) {
			s3 = peg$parsePositiveDecimal();
			if (s3 !== peg$FAILED) {
			    peg$savedPos = s0;
			    s1 = peg$c30(s3);
			    s0 = s1;
			} else {
			    peg$currPos = s0;
			    s0 = peg$FAILED;
			}
		    } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
		if (s0 === peg$FAILED) {
		    s0 = peg$currPos;
		    s1 = peg$parseInteger();
		    if (s1 !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 46) {
			    s2 = peg$c25;
			    peg$currPos++;
			} else {
			    s2 = peg$FAILED;
			    if (peg$silentFails === 0) { peg$fail(peg$c26); }
			}
			if (s2 === peg$FAILED) {
			    s2 = null;
			}
			if (s2 !== peg$FAILED) {
			    peg$savedPos = s0;
			    s1 = peg$c31(s1);
			    s0 = s1;
			} else {
			    peg$currPos = s0;
			    s0 = peg$FAILED;
			}
		    } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		    }
		}
	    }

	    return s0;
	}

	function peg$parseInteger() {
	    var s0, s1, s2, s3, s4;

	    s0 = peg$currPos;
	    s1 = [];
	    if (peg$c23.test(input.charAt(peg$currPos))) {
		s2 = input.charAt(peg$currPos);
		peg$currPos++;
	    } else {
		s2 = peg$FAILED;
		if (peg$silentFails === 0) { peg$fail(peg$c24); }
	    }
	    if (s2 !== peg$FAILED) {
		while (s2 !== peg$FAILED) {
		    s1.push(s2);
		    if (peg$c23.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		    } else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c24); }
		    }
		}
	    } else {
		s1 = peg$FAILED;
	    }
	    if (s1 !== peg$FAILED) {
		peg$savedPos = s0;
		s1 = peg$c28(s1);
	    }
	    s0 = s1;
	    if (s0 === peg$FAILED) {
		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 45) {
		    s1 = peg$c2;
		    peg$currPos++;
		} else {
		    s1 = peg$FAILED;
		    if (peg$silentFails === 0) { peg$fail(peg$c3); }
		}
		if (s1 !== peg$FAILED) {
		    s2 = peg$parse_();
		    if (s2 !== peg$FAILED) {
			s3 = [];
			if (peg$c23.test(input.charAt(peg$currPos))) {
			    s4 = input.charAt(peg$currPos);
			    peg$currPos++;
			} else {
			    s4 = peg$FAILED;
			    if (peg$silentFails === 0) { peg$fail(peg$c24); }
			}
			if (s4 !== peg$FAILED) {
			    while (s4 !== peg$FAILED) {
				s3.push(s4);
				if (peg$c23.test(input.charAt(peg$currPos))) {
				    s4 = input.charAt(peg$currPos);
				    peg$currPos++;
				} else {
				    s4 = peg$FAILED;
				    if (peg$silentFails === 0) { peg$fail(peg$c24); }
				}
			    }
			} else {
			    s3 = peg$FAILED;
			}
			if (s3 !== peg$FAILED) {
			    peg$savedPos = s0;
			    s1 = peg$c32(s3);
			    s0 = s1;
			} else {
			    peg$currPos = s0;
			    s0 = peg$FAILED;
			}
		    } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		    }
		} else {
		    peg$currPos = s0;
		    s0 = peg$FAILED;
		}
	    }

	    return s0;
	}

	function peg$parseIndex() {
	    var s0, s1;

	    s0 = peg$currPos;
	    s1 = peg$parseAtom();
	    if (s1 !== peg$FAILED) {
		peg$savedPos = s0;
		s1 = peg$c33(s1);
	    }
	    s0 = s1;

	    return s0;
	}

	function peg$parsePronumeral() {
	    var s0;

	    if (peg$c34.test(input.charAt(peg$currPos))) {
		s0 = input.charAt(peg$currPos);
		peg$currPos++;
	    } else {
		s0 = peg$FAILED;
		if (peg$silentFails === 0) { peg$fail(peg$c35); }
	    }

	    return s0;
	}

	function peg$parse_() {
	    var s0, s1;

	    peg$silentFails++;
	    s0 = [];
	    if (peg$c37.test(input.charAt(peg$currPos))) {
		s1 = input.charAt(peg$currPos);
		peg$currPos++;
	    } else {
		s1 = peg$FAILED;
		if (peg$silentFails === 0) { peg$fail(peg$c38); }
	    }
	    while (s1 !== peg$FAILED) {
		s0.push(s1);
		if (peg$c37.test(input.charAt(peg$currPos))) {
		    s1 = input.charAt(peg$currPos);
		    peg$currPos++;
		} else {
		    s1 = peg$FAILED;
		    if (peg$silentFails === 0) { peg$fail(peg$c38); }
		}
	    }
	    peg$silentFails--;
	    if (s0 === peg$FAILED) {
		s1 = peg$FAILED;
		if (peg$silentFails === 0) { peg$fail(peg$c36); }
	    }

	    return s0;
	}

	peg$result = peg$startRuleFunction();

	if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	    return peg$result;
	} else {
	    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
		peg$fail(peg$endExpectation());
	    }

	    throw peg$buildStructuredError(
		peg$maxFailExpected,
		peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
		peg$maxFailPos < input.length
		    ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
		    : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
	    );
	}
    }

    return {
	SyntaxError: peg$SyntaxError,
	parse:       peg$parse
    };
})();

//===================================
// Utility functions

function makeInt(o) {
    return new Decimal(o.join(""));
}
function makeFloat(whole,part) {
    return new Decimal(whole.join(""),part.join(""));
}
function gcd(a,b)
{ 
    if (b == 0){
	//	console.log("gcd="+a);
	return Math.abs(a);
    }
    else {
	return gcd(b, a % b);
    }
}

function randBetween(from,to) {
    return Math.floor(Math.random()*(to-from+1)+from);
}
//===================================

const RANDOM = { pronumeral:1, integer:2, fixed:3, term:4 };
class RandomSpecifier {
    constructor(t, lb, ub, precision) {
	this.type = t;
	this.lb=lb;
	this.ub=ub;
	this.precision=precision;
    }
}

// class Rational -- exact representation of fractions
class Rational {
    constructor(num,den) {
	if(num instanceof Rational) {
	    this.numerator=num.numerator;
	    this.denominator=num.denominator;
	} else {
	    this.numerator = num;
	    if(den === undefined) den=1
	    if(den === 0) throw new Error("Rational type cannot have denominator of zero.");
	    this.denominator = den;
	    this.canonicalSign();
	}
    }
    clone() {
	return new this.constructor(this);
    }
    // make the denominator positive
    canonicalSign() {
	if(this.denominator<0) {
	    this.denominator *= -1;
	    this.numerator *= -1;
	}
    }
    multiply(other) {
	var rval=this.clone();
	if(other instanceof Rational) {
	    rval.numerator *= other.numerator;
	    rval.denominator *= other.denominator;
	} else {
	    rval.numerator *= other;
	}
	return rval;
    }
    divide(other) {
	// should check class here ... we'll leave it fragile for now
	var rval=this.clone();
	rval.numerator *= other.denominator;
	rval.denominator *= other.numerator;
	rval.canonicalSign();
	return rval;
    }
    negate() {
	var rval=this.clone();
	rval.numerator *= -1;
	return rval;
    }
    simplify() {
	var rval=this.clone();
	var factor = gcd(this.numerator,this.denominator);
	rval.numerator /= factor;
	rval.denominator /= factor;
	return rval;
    }
    isSimple() {
	return 1==gcd(this.numerator,this.denominator);
    }
    add(other) {
	var rval=this.clone();
	var adjust = gcd(this.denominator,other.denominator);
	var factor = other.denominator / adjust;
	var otherFactor = this.denominator / adjust;
	rval.numerator = this.numerator*factor + other.numerator*otherFactor;
	rval.denominator=this.denominator*factor;
	return rval;
    }
    subtract(other) {
	return add(other.negate());
    }
    reciprocal() {
	return new Rational(this.denominator, this.numerator);
    }
    toString() { return this.numerator.toString()+"/"+this.denominator.toString(); }
    isEqual(that) {
	if(that instanceof Rational) return (this.numerator*that.denominator == this.denominator*that.numerator);
	if(that.constructor.name === Number.name) return (this.numerator == this.denominator*that);
	return false;
    }
}

// class Decimal: for exact arithmetic for (small) fixed point numbers
// Subclass of Rational??
    // construct using two integers: f is the number with the decimal point removed (i.e. the numerator),
    // p is the number to divide f by to turn it into the real fixed point number (i.e. the denominator)
    // f should always be a power of 10: 10 for one decimal place, 100 for two, 1000 for three, etc.
// OR
// construct using two strings, the integer part and the fraction part
// or construct using two integers, an integer part and a fraction part
// or construct using another Decimal to clone it.
class Decimal extends Rational{
    constructor(f,p) {
	if(typeof f === "string") {
	    var decimalPart = (p||"");
	    // keep at most 7 decimal places
	    decimalPart = decimalPart.slice(0,7);
	    var numerator = Number.parseInt(f.concat(decimalPart));
	    var denominator = Decimal.POW[decimalPart.length];
	    super(numerator,denominator);
	} else if(f instanceof Rational) super(f);
	else if(f instanceof RandomSpecifier && f.type == RANDOM.fixed) super(randBetween(f.lb,f.ub,f.precision));
	else super(f,p);
    }
    static get POW() { return [1,10,100,1000,10000,100000,1000000,10000000] };
/*
    multiply(other) { return new Decimal(this.value.multiply(other.value)); }
    add(other) { return new Decimal(this.value.add(other.value)); }
    negate() { return new Decimal(this.value.negate()); }
    divide(other) { return new Decimal(this.value.divide(other.value)); }
*/
    toFloat() { return this.numerator/this.denominator; }
    get isInteger() { return this.denominator === 1; }
    toString() {
	var s=this.numerator.toString();
	if(this.isInteger) return s;
	var places=Decimal.POW.indexOf(this.denominator);
	if(places<0) throw new Error("Decimal type encountered with non-standard denominator.");
	var iPart = s.slice(0,-places);
	if(iPart.length==0) iPart="0"
	var dPart = s.slice(-places);
	return iPart+"."+dPart;
    }
    // add \, every three digits counting away from the decimal point.
    toLaTeX() {
	var s=this.numerator.toString();
	if(this.isInteger) {
	    iPart=s;
	    dPart="";
	} else {
	    var places=Decimal.POW.indexOf(this.denominator);
	    if(places<0) throw new Error("Decimal type encountered with non-standard denominator.");
	    var iPart = s.slice(0,-places);
	    if(iPart.length==0) iPart="0"
	    var dPart = s.slice(-places);
	}
	iPart = iPart.replace(/(\d)(\d{3})$/g,"$1\\,$2");
	while(iPart.match(/\d{4}/)) { iPart=iPart.replace(/(\d)(\d{3})\\,/,"$1\\,$2\\,"); }
	if(!this.isInteger) {
	    dPart = dPart.replace(/^(\d{3})(\d)/,"$1\\,$2");
	    while(dPart.match(/\d{4}/)){ dPart=dPart.replace(/(,\d{3})(\d)/,"$1\\,$2"); }
	    dPart="."+dPart;
	}
	return iPart+dPart;
    }
    toMathML() {
	return "<mn>"+this.toString()+"</mn>";
    }
    // Fixed point division is problematic. If we're working with one decimal place numbers, we don't want
    // to explode to umpteen decimals, but that's what will happen with most divisions resulting in non-terminating
    // decimals. We can round to a particular precision, at the cost of losing accuracy, but what precision to use?
    // Ideally, dividing by (say) 2.3 then multiplying by 2.3 should return us to the original number, but multiplying
    // increases the number of decimal places so dividing would need to reduce the number of decimal places, but that's
    // often going to be impossible (e.g. 5 / 2.3 cannot have -1 decimal places).
    // For now, we only allow division where the divisor is a factor of the numerator so as to not change the precision
    // of the fixed point number, and leave the denominator unchanged.
    divide(that) {
	if(! that instanceof Decimal) throw Error("Decimals can only be divided by other Decimals.");
	if((this.numerator % that.numerator)!=0 || that.denominator>this.denominator)
	    throw Error("Fixed point division is problematic (so we don't allow it except for very simple cases)");
	return new Decimal(this.numerator/that.numerator, this.denominator/that.denominator)
    }
    get isZero() { return this.numerator == 0; }
    get isUnity() { return this.numerator == this.denominator; }
    get sign() { return this.numerator<0?-1:(this.numerator==0?0:1); }
    negate() {
	return new Decimal(-this.numerator, this.denominator);
    }
    // exponentiation is problematic (see notes on division above) unless the exponent is a non-negative integer
    pow(exponent) {
	if(! exponent instanceof Decimal) exponent = new Decimal(exponent);
	if(! exponent.isInteger || exponent.sign<0 ) throw new Error("We only allow small, non-negative positive exponents.");
	var rval = new Decimal(1);
	for(var i=0;i<exponent.numerator; i++) {
	    rval.numerator *= this.numerator;
	    rval.denominator *= this.denominator;
	}
	return rval;
    }
    abs() {
	return new Decimal(this.numerator<0?-this.numerator:this.numerator, this.denominator);
    }
/*
    isEqual(that) {
	if(typeof that === "number" || (that instanceof Rational)) return this.value.isEqual(that);
	if(that instanceof Decimal) return this.value.isEqual(that.value);
	return false;
    }
*/
}
	

// ==================================
// Class Atom
//
// An atom is an encapsulation of one of several things:
//    - a Decimal number
//    - a pronumeral
//    - an expression
//    - a function
//
class Atom {
    constructor(f) {
    	if(f instanceof Atom) {
	    if(f.item.clone) this.item = f.item.clone();
	    else this.item = f.item;
	} else if(f instanceof RandomSpecifier) {
	    if(f.type===RANDOM.pronumeral) {
		// generate random pronumeral atoms
		var possible = "aaaaaaaaaaaaaaaabbbbbbbbbbbcdefghstuvwwxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyy";
		this.item = possible.charAt(Math.floor(Math.random() * possible.length));
	    } else if(f.type===RANDOM.fixed) {
		this.item = new Decimal(f);
	    }
	} else if(typeof f == "number") this.item = new Decimal(f);
    	else this.item = f;
    }
    toString() {
	return this.item.toString();
    }
    toLaTeX() {
	if(this.isExpression || this.isDecimal || this.isFunction)
	    return this.item.toLaTeX();
	else return this.item;
    }
    toMathML() {
	if(this.isExpression)
	    return "<mfenced>"+this.item.toMathML()+"</mfenced>";
	else if(this.isDecimal || this.isFunction)
	    return this.item.toMathML();
	else return '<mi>'+this.item+'</mi>';
    }
    clone() {
    	return new Atom(this);
    }
    // an atom is 'wrapped' (in brackets) if its item is an Expression with a single positive Term
    // (or a negative numeric term) with a single Factor
    // to the power of one.
    // Such an atom can be unwrapped (replaced with the factor) without changing the semantics
    get isWrapped() {
	return (this.isExpression) &&
	    (this.item.length == 1) &&
	    (this.item.terms[0].length == 1) &&
	    (this.item.terms[0].sign == 1 || this.item.terms[0].factors[0].isDecimal) &&
	    (this.item.terms[0].factors[0].hasUnityIndex);
    }
    get isExpression() {
	return this.item.constructor.name === Expression.name;
    }
    get isDecimal() {
	return this.item instanceof Decimal;
    }
    // TODO when functions are implemented
    get isFunction() {
	return false;
    }
    get isPronumeral() {
	return typeof(this.item) === "string" && this.item.length===1;
    }
    unwrap() {
	if(this.isWrapped) {
	    if(this.item.terms[0].sign==-1) 
		return new Atom(-this.item.terms[0].factors[0].factor);
	    else
		return new Atom(this.item.terms[0].factors[0].factor);
	} else return this;
    }
    // TODO: deal with functions
    isEqual(value) {
	if(value instanceof Atom) value = value.item;
	if(this.isDecimal || this.isExpression) return this.item.isEqual(value);
	else if(this.isPronumeral) return value===this.item;
	else return false;
    }
    // operator used for sorting only
    compare(value) {
	if(this.isDecimal) {
	    if(value instanceof Decimal) return this.item.subtract(value);
	    else return -1; // numbers are "less than" anything else
	} else return 0; // shouldn't happen ... we should only call this on numeric values
    }
	
}


// ==========================================
// Class Factor
//
// A factor is an encapsulation of a base and an index.
// We call the base 'factor'.
//
// factor and index are both instances of class Atom.
// ==========================================

class Factor {
    constructor(atom,index) {
	this.factor = new Atom(atom);
    	if(index===undefined) this.index=Factor.UNITY;
    	else this.index = new Atom(index);
    }
    static get UNITY() {
	if(! Factor.one) Factor.one = new Atom(new Decimal(1));
	return Factor.one;
    }
    static get NEGATIVE_UNITY() {
	if(! Factor.negativeOne) Factor.negativeOne = new Atom(new Decimal(-1));
	return Factor.negativeOne;
    }
    // hasUnityIndex
    // The index is a number equal to one
    get hasUnityIndex() {
	return this.index.isEqual(Factor.UNITY.item);
    }
    // unwrap -- simplify by unwrapping factor and index if either is a wrapped atom
    unwrap() {
	return new Factor(this.factor.unwrap(), this.index.unwrap());
    }
    toString() {
	var exponent="";
	if(this.index.item !=1) exponent="^"+(this.index.toString?this.index.toString():this.index);
    	if(this.factor.toString)
    	    return "("+this.factor.toString()+")"+exponent;
    	else
    	    return "("+this.factor+")"+exponent;
    }
    toMathML() {
	var exponent="";
	var msup="";
	if(this.index.item !=1) {
	    msup="<msup>";
	    exponent=this.index.toMathML()+"</msup>";
	}
    	return msup+this.factor.toMathML()+exponent;
    }
    toLaTeX() {
	var exponent="";
	if(this.index.item !=1) exponent="^{"+this.index.toLaTeX()+"}";
    	if(this.isExpression)
    	    return '\\left('+this.factor.toLaTeX()+'\\right)'+exponent;
    	else
    	    return this.factor.toLaTeX()+exponent;
	
    }
    get isNumeric() {
	return this.factor.isNumber;
    }
    get isExpression() {
	return this.factor.isExpression;
    }
    get isPronumeral() {
	return this.factor.item.constructor.name==String.name;
    }
    isLike(other) {
	// different types => unlike
	if(this.factor.item.constructor.type != other.factor.item.constructor.type) return false;
	// both numeric => like
	if(this.isNumeric && other.isNumeric) return true;
	// different type of index => unlike
	if(this.index.item.constructor.name != other.index.item.constructor.name) return false;
	// different non-expression index => unlike
	if(! this.index.isExpression &&
	   ! this.index.isEqual(other.index)) return false;
	// different expression index => unlike
	// TODO
	if(this.index.isExpression &&
	   !this.index.isEqual(other.index)) return false;
	// At this point we have equal indices, so if we have equal factors we are like
	return this.factor.isEqual(other.factor);
    }
    clone() {
    	return new Factor(this.factor, this.index);
    }
}


// =========================================
// Class Term
//
// A term is a collection of factors
// with a sign.
// Terms can be sorted (to put numeric factors first and
// pronumeral factors in alphabetical order),
// collected (to combine like factors) and expanded (to
// multiply out any expression factors)
//
// =========================================


class Term {
    constructor(f) {
	//	    console.log("Term constructor");
    	this.sign=1;
	if(f===undefined) {
	    this.factors=[];
	} else if(f instanceof Term) {
	    //		console.log("cloning term");
    	    this.factors = [];
    	    f.factors.forEach( function(item) { 
		this.factors.push(item.clone());
    	    } , this);
    	    this.sign=f.sign;
	} else if(f instanceof RandomSpecifier && f.type == RANDOM.term) {
	    // generate a term with a random number of pronumeral factors between bounds specified by the RandomSpecifier
	    this.factors=[];
	    for(var i=0; i<f.ub; i++) {
		if(i < f.lb || randBetween(0,1)) {
		    this.factors.push(new Factor(new RandomSpecifier(RANDOM.pronumeral)));
		}
	    }
	} else {
	    // neither cloning a term, nor generating a random term, we assume f is either a factor, or an array of factors
            if(Array.isArray(f)) {
		//                  console.log("term from array of factors");
    		this.factors=[];
    		f.forEach( function(item) {
    		    this.factors.push(item.clone());
    		}, this);
    	    } else {
		this.factors=[f.clone()];
		//                    console.log("term from factor ");
		//                    console.log(f);
		//		    console.log(f.toString());
		//		    console.log(this);
		//                    console.log(this.toString());
    	    }
	}
    }

    negate() {
	var t = this.clone();
    	t.sign*=-1;
    	return t;
    }
    clone() {
    	return new Term(this);
    }
    toString() {
	var s = "";
	this.factors.forEach( function(item) { 
            if(item !==undefined) {
		if(item.toString)
    		    s+= item.toString(); 
		else
    		    s+=".<"+item.constructor.name+">";
            } else {
		s+= "[undefined term]";
            }
	} );
    	s=" "+s+" ";
    	if(this.sign==-1) s="-"+s;
	return s;
    }
    toLaTeX() {
	var s = "";
	var num = "";
	var den = "";
	var prevNumNumber=false;
	var prevDenNumber=false;
	this.factors.forEach( function(item) { 
            if(item !==undefined) {
		if(item.index.isDecimal && item.index.item.sign < 0) {
		    // a negative numeric index => denominator factor
		    var cpy = item.clone();
		    cpy.index.item=cpy.index.item.negate();
		    if(item.factor.isDecimal) {
			if(prevDenNumber) den+='\\times ';
			prevDenNumber=true;
		    } else prevDenNumber=false;
		    den += cpy.toLaTeX();
		} else {
		    // numerator factor
		    if(item.factor.isDecimal) {
			if(prevNumNumber) num+='\\times ';
			prevNumNumber=true;
		    } else prevNumNumber=false;
		    num += item.toLaTeX();
		}
            } else {
		throw new Error("Undefined factor in term");
            }
	} );
	if(den>"") {
	    if(num=="") num="1";
	    s+='\\frac{'+num+'}{'+den+'}'
	} else s+=num;
	//s=" "+s+" ";
    	if(this.sign==-1) s="-"+s;
	return s;
    }
    toMathML() {
	var s = "";
	var num = "";
	var den = "";
	var numCount=0;
	var denCount=0;
	var prevNumNumber=false;
	var prevDenNumber=false;
	this.factors.forEach( function(item) { 
            if(item !==undefined) {
		if(item.index.isDecimal && item.index.item.numerator < 0) {
		    var cpy = item.clone();
		    cpy.index.item.numerator *= -1;
		    if(denCount>0) {
			if(item.factor.isDecimal) {
			    if(prevDenNumber) den+='<mo>&times;</mo>';
			    else den+="<mo>&InvisibleTimes;</mo>";
			} else {
			    den+="<mo>&InvisibleTimes;</mo>";
			}
		    }
		    prevDenNumber = item.factor.isDecimal;
		    den += cpy.toMathML();
		    denCount++;
		} else {
		    if(numCount>0) {
			if(item.factor.isDecimal) {
			    if(prevNumNumber) num+='<mo>&times;</mo>';
			    else num+="<mo>&InvisibleTimes;</mo>";
			} else {
			    num+="<mo>&InvisibleTimes;</mo>";
			}
		    }
		    prevNumNumber = item.factor.isDecimal;
		    num += item.toMathML();
		    numCount++;
		}
            } else {
		throw new Error("Undefined factor in term");
            }
	} );
	if(denCount>0) {
	    if(numCount==0) num="<mn>1<mn>";
	    s+="<mfrac><mrow>"+num+"</mrow><mrow>"+den+"</mrow>";
	} else s+=num;
    	// we don't apply the sign at term level but at Expression level.
	//if(this.sign==-1) s="-"+s;
	return s;
    }
    // multiply a term by a factor, or another term, or a number.
    // We multiply by appending to the list of terms, and multiplying signs.
    // Returns a new term; original term is unchanged.
    multiply(f) {
	var cpy = this.clone();
    	if(f instanceof Factor) {
	    //		console.log("multiply by factor "+f.toString());
    	    cpy.factors.push(f.clone()); // don't retain the factor itself, keep a clone of it instead to avoid side effects
    	} else if (f instanceof Term) {
	    //		console.log("multiply by term "+f.toString());
    	    cpy.factors = this.factors.concat(f.clone().factors);
	    cpy.sign *= f.sign;
	    //    	      } else {
	    //		console.log("Tried to multiply by "+f.constructor.name);
    	} else {
	    // if neither a term nor a factor, make a new factor of the (presumed) number or pronumeral
	    // and add it to the factor list
	    cpy.factors.push(new Factor(f));
	}
	return cpy;
    }
    get length() {
	return this.factors.length;
    }
    // findFactorLike
    // tests to see if a pronumeral is present in the first n elements.
    // If present, returns the index of the factor, otherwise returns -1.
    // p is a single character string, it does not need to be an Atom (but will still work if it is).
    findFactorLike(p, n) {
	if(n===undefined) n=this.length;
	if(p instanceof Atom) p=p.item;
	return this.factors.slice(0,n).findIndex(function(el){ return el.factor.item===p; });
    }
    // substitute values for pronumerals
    // subs is an object { pronumeral, value }
    // where pronumeral is a string, and value is an Atom.
    // Alternatively, subs may be an array of such objects.
    substitute(subs) {
	if(! (subs instanceof Array) ) subs = [ subs ];
	// the value of each sub should be either a valid Atom item: a number or a pronumeral or an expression
	// NOT a factor, and NOT a term ... either of these should be packaged as an expression
	subs.forEach(function(sub) {
	    if(sub.value instanceof Factor) sub.value = new Expression(new Term(sub.value));
	    else if(sub.value instanceof Term) sub.value = new Expression(sub.value);
	    else if(! sub.value instanceof Decimal && !( typeof sub.value == "string" && sub.value.length!=1 ) )
		throw new Error("Only decimal, pronumeral, factor, term or expression types can be the value for substitution.");
	});
	var rval = this.clone();
	// for each factor, 
	this.factors.forEach(function(fact, idx) {
	    // do the substitution on any expression factors or expression indices
	    if(fact.factor.isExpression)
		rval.factors[idx].factor.item=fact.factor.item.substitute(subs);
	    if(fact.index.isExpression)
		rval.factors[idx].index.item = fact.index.item.substitute(subs);
	    // for each subs
	    subs.forEach(function(sub) {
		// if factor = pronumeral, substitute
		if(sub.pronumeral == fact.factor.item) 
		    rval.factors[idx].factor.item=sub.value;
		// if index = pronumeral, substitute
		if(fact.index.isPronumeral && sub.pronumeral == fact.index.item)
		    rval.factors[idx].index.item=sub.value;
	    });
	});
	// return the new term
	return rval;
    }
    
    // hasRepeatedFactors
    // tests to see if any pronumeral factor is repeated
    get hasRepeatedFactors() {
	var seenFactors = {};
	return this.factors.some(function(el,idx,ary){
	    // only test pronumeral factors
	    if(!el.factor.isPronumeral) return false;
	    if(seenFactors.hasOwnProperty(el.factor.item)) return true;
	    seenFactors[el.factor.item]=idx;
	    return false;
	});
    }
    // hasExpressionFactor
    // return true if any of the factors have type Expression for factor
    // (or non-numeric index)??
    get hasExpressionFactor() {
	return this.factors.some(function(el,idx,ary){
	    if(el.factor.isExpression) return true;
	    // if(!el.index.isDecimal) return true;
	    return false;
	});
    }
    // canSimplifyCoefficient
    // returns false if:
    //  - there exists no numeric factors
    //  - there exists only one numeric factor having an index of 1
    //  - there exists only one numeric factor (that is an integer) with index 1 or -1
    //  - there exists only two numeric factors, (both integers,) one with index 1 the other with index -1
    //    and the GCD of the two is equal to 1.
    // otherwise returns true
    // *** Because we're restricting division of fixed point numbers, we're going to call a single numerator
    // and single denominator simple, even if they're not integers
    get canSimplifyCoefficient() {
	var f = this.numericFactors;
	if(f.length==0) return false;
	if(f.length==1 && f[0].hasUnityIndex) return false;
	if(f.length==1 && f[0].isNumber && f[0].index.isNumber && f[0].index.item.negate.isUnity) return false;
	if(f.length==2 &&
	   f[0].factor.isDecimal && f[1].factor.isDecimal &&
	   ((f[0].hasUnityIndex && f[1].index.item.negate().isUnity) ||
	    (f[1].hasUnityIndex && f[0].index.item.negate().isUnity))
	  ) return false;
	return true;
    }
    // isSimple
    // return true if we cannot simplify the coefficient, there are no repeated factors, and there
    // are no Expression factors
    get isSimple() {
	return ! this.canSimplifyCoefficient &&
	    ! this.hasRepeatedFactors &&
	    ! this.hasExpressionFactor;
    }
    
    // numericFactors
    // return just the constant numeric factors (i.e. factors that make up the coefficient)
    // return value is just an array of factors, not a Term.
    get numericFactors() {
	return this.factors.filter( function(el) {
	    return el.factor.isDecimal && el.index.isDecimal;
	} );
    }
    get nonNumericFactors() {
	return this.factors.filter( function(el) {
	    return !(el.factor.isDecimal && el.index.isDecimal);
	} );
    }
    // pronumerals
    // return an array of pronumerals in alpha order for comparison
    get pronumerals() {
	var p=this.factors.filter( function(el) {
	    return el.factor.isPronumeral && el.index.isDecimal;
	} );
	return p.sort( function(a,b) {
	    var af = a.factor.item, bf=b.factor.item, ai=a.index.item, bi=b.index.item;
	    return ((af<bf)?-1:((af>bf)?1:((ai>bi)?1:((ai<bi)?-1:0))));
	} );
    }
    // sortFactors
    // Numeric factors first in ascending order
    // Pronumerals next in alpha order
    // Expressions last in the order they're given
    sortFactors() {
	var cpy = new Term();
	cpy.sign=this.sign;
	cpy.factors = this.clone().factors.sort(function(fa,fb){
	    var a=fa.factor.item;
	    var b=fb.factor.item;
	    if(fa.factor.isDecimal) {
		if(fb.factor.isDecimal) return fa.factor.compare(fb.factor);
		else return -1;
	    } else if (fb.factor.isDecimal) {
		return 1;
	    } else if (typeof a == "string") {
		if(typeof b == "string") return ((a>b)?1:((a==b)?0:-1));
		else return -1;
	    } else if (typeof b == "string") {
		return 1;
	    }
	});
	return cpy;
    }

    // unwrap
    // unwrap any factors that have unnecessary brackets
    unwrap() {
	var cpy = new Term(this.factors.reduce(function(sum,el){
	    sum.push(el.unwrap());
	    return sum;
	}, []));
	cpy.sign = this.sign;
	return cpy;
    }
    // collectFactors:
    // combine any pronumeral factors
    // Handling of numeric factors was like this:
      // combine any decimal factors
      // combine any integer factors with positive indices
      // combine any integer factors with negative indices
      // if integer factors exist with both positive and negative
      //    indices, divide both by their GCD
    // But I want to keep numerators and denominators intact because if we try to combine them
    // nice fixed point numbers become nasty recurring decimals.
    // For integers, we'll divide numerator and denominator by their GCD
    // For fixed point numbers we will not do any simplification.
    // The at the end, after simplifying integer factors, we will combine integer and decimal factors.
    collectFactors() {
	var decimalNumeratorFactor = undefined;
	var decimalDenominatorFactor = undefined;
	var numeratorFactor = undefined;
	var denominatorFactor = undefined;
	var seenFactors = {};
	var cpy=new Term();
	cpy.sign = this.sign;
	this.factors.forEach(function(el,idx,ary) {
	    if(el.factor.isPronumeral) { // it's a pronumeral
		if(seenFactors.hasOwnProperty(el.factor.item)) {
		    // we have seen the pronumeral before ... add indices
		    var i=seenFactors[el.factor.item];
		    // deal with numeric indices
		    if(cpy.factors[i].index.isDecimal &&
		       el.index.isDecimal ) {
			cpy.factors[i].index.item = cpy.factors[i].index.item.add(el.index.item);
			//TODO: test non-numeric index handling
		    } else if(cpy.factors[i].index.isExpression) { // that index is an expression
			// construct a term and add it to the index
			var t = new Term(new Factor(el.index.clone()));
			cpy.factors[i].index.item=cpy.factors[i].index.item.add(t);
		    } else if(el.index.isExpression) { // this index is an expression
			// construct an expression and add the index to it
			var e = new Expression(new Term(new Factor(cpy.factors[i].index.clone())));
			cpy.factors[i].index.item = e.add(el.index.item);
		    }
		} else {
		    // first time we have encountered this pronumeral ... add it to the copy's factor list and remember it.
		    seenFactors[el.factor.item]=cpy.length;
		    cpy = cpy.multiply(el);
		}
	    } else if(el.factor.isDecimal) { // it's a numeric term
		if(el.factor.item.isInteger && el.index.isDecimal && el.index.item.isInteger) { // integer factor
		    var d = el.factor.item.pow(el.index.item.abs());
		    if(el.index.item.sign>0) { // numerator factor
			if(numeratorFactor===undefined) {
			    var numerator=new Factor(d);
			    numeratorFactor = cpy.length;
			    cpy = cpy.multiply(numerator);
			} else {
			    cpy.factors[numeratorFactor].factor.item = cpy.factors[numeratorFactor].factor.item.multiply(d);
			}
		    } else { // denominator factor
			if(denominatorFactor===undefined) {
			    var denominator=new Factor(d,Factor.NEGATIVE_UNITY);
			    denominatorFactor = cpy.length;
			    cpy=cpy.multiply(denominator);
			} else {
			    cpy.factors[denominatorFactor].factor.item = cpy.factors[denominatorFactor].factor.item.multiply(d);
			}
		    }
		} else { // numeric but not integer
		    var expanded = el.factor.item.pow(el.index.item.abs())
		    if(el.index.item > 0) { // numerator factor
			if(decimalNumeratorFactor === undefined) {
			    decimalNumeratorFactor = cpy.length;
			    cpy=cpy.multiply(expanded);
			} else {
			    cpy.factors[decimalNumeratorFactor].factor.item
				=cpy.factors[decimalNumeratorFactor].factor.item.multiply(expanded);
			}
		    } else { // denominator factor
			if(decimalDenominatorFactor === undefined) {
			    decimalDenominatorFactor = cpy.length;
			    cpy=cpy.multiply(new Factor(expanded,Factor.NEGATIVE_UNITY));
			} else {
			    cpy.factors[decimalDenominatorFactor].factor.item
				=cpy.factors[decimalDenominatorFactor].factor.item.multiply(expanded);
			}
		    }
		}
	    } else if(el.factor.isExpression) {
		cpy=cpy.multiply(new Factor(el.factor.item.collectFactors(),el.index));
	    }
	});
	// make any numeric factors positive
	[numeratorFactor, denominatorFactor, decimalNumeratorFactor, decimalDenominatorFactor].forEach(function(el){
	    if(el!==undefined && cpy.factors[el].factor.item.sign<0) {
		cpy.sign *= -1;
		cpy.factors[el].factor.item=cpy.factors[el].factor.item.negate();
	    }
	});
	// simplify numerator and denominator if possible
	if(numeratorFactor!==undefined && denominatorFactor!==undefined) {
	    var g=gcd(cpy.factors[numeratorFactor].factor.item,
		      cpy.factors[denominatorFactor].factor.item);
	    cpy.factors[numeratorFactor].factor.item = cpy.factors[numeratorFactor].factor.item.divide(new Decimal(g));
	    cpy.factors[denominatorFactor].factor.item = cpy.factors[denominatorFactor].factor.item.divide(new Decimal(g));
	}
	
	// if we have a decimal*Factor, collapse integer numerator factors into it
	if(numeratorFactor!==undefined && decimalNumeratorFactor!==undefined) {
	    cpy.factors[decimalNumeratorFactor].factor.item =
		cpy.factors[decimalNumeratorFactor].factor.item.multiply(cpy.factors[numeratorFactor].factor.item);
	    cpy.factors[numeratorFactor].index.item=0;
	}
	if(denominatorFactor!==undefined && decimalDenominatorFactor!==undefined) {
	    cpy.factors[decimalDenominatorFactor].factor.item =
		cpy.factors[decimalDenominatorFactor].factor.item.multiply(cpy.factors[denominatorFactor].factor.item);
	    cpy.factors[denominatorFactor].index.item=0;
	}
    
    // finally, remove any factors with zero indices, or unity factors
	cpy.factors = cpy.factors.filter(function(el) {
	    return ! (el.index.isDecimal && el.index.item.isZero) &&
		! (el.factor.isDecimal && el.factor.item.isUnity);
	});
	// but if there are none left, we make one
	if(cpy.length == 0)
	    cpy.factors.push( new Factor(1) );
	return cpy;
    }
    // expand
    // If the term contains a factor that is a bracketed Expression (with a positive numeric integer index),
    // (looking from right to left), create a new Expression by multiplying by every other factor.
    // Non-recursive ... do it once and stop.
    // Return value: expanded expression, or false if there are no expression factors.
    expand() {
	// find the last Expression in the stack
	var expr = this.length-1;
	for(; expr>=0; expr--) {
	    var el=this.factors[expr];
	    if(el.factor.isExpression
	       && el.index.isDecimal && el.index.item.isInteger
	       && el.index.item.sign>0) break;
	}
	if(expr==-1) return false; // we didn't find any expressions to expand
	// make a multiplier term of everything except the expression we found
	var premultiplier = (expr>0)?new Term(this.factors.slice(0,expr)):undefined;
	if(this.factors[expr].index.item > 1) {
	    var e = new Factor(this.factors[expr].factor, this.factors[expr].index.item.add(Factor.NEGATIVE_UNITY.item));
	    premultiplier=(premultiplier===undefined)?new Term(e):premultiplier.multiply(e);
	}
	// TODO: deal with expanding expressions with negative indices?
	var postmultiplier = (expr+1<this.length)?(new Term(this.factors.slice(expr+1,this.length))):undefined;
	// clone the expression and multiply it by the multiplier (where Expression.multiply takes care of the
	// term-by-term multiplication
	var expression = this.factors[expr].factor.item.clone().multiply(premultiplier,postmultiplier);
	//	      if(this.sign<0) return expression.negate(); else return expression;
	return expression;
    }
    // expandAll()
    // first do one expand on this term, then expand the resulting expression
    expandAll() {
	var expr = this.expand();
	if(expr) return expr.expandAll();
	else return false;
    }
    // simplify
    // Simplifying a term just means collecting and sorting factors.
    // This does *not* expand any expression factors.
    simplify() {
	return this.collectFactors().sortFactors();
    }
    // isLike -- tests to see if this is mathematically like another term (without expanding or anything else).
    // To be like, all non numeric factors must exist in both.
    isLike(that) {
	// take a copy of this & that as we're going to delete factors as we find them in other until we run out or find
	// a factor in other that is not in this.
	// Simplify the copies otherwise xx will not match x^2 (since we match factor by factor).
	// Simplify also ensures that factors in both are in the same order.
	var thisCopy=this.simplify();
	var thatCopy=that.simplify();
	// discard numeric factors
	// (if either term has no factors, treat it as equal to one.)
	while(thisCopy.length > 0 && thisCopy.factors[0].factor.isDecimal) thisCopy.factors.shift();
	while(thatCopy.length > 0 && thatCopy.factors[0].factor.isDecimal) thatCopy.factors.shift();
	// if they're not the same length after removing numeric factors, they can't be like terms
	if(thisCopy.length != thatCopy.length) return false;
	// now, matching factors should be in matching order, so we just repeatedly check the first factors then shift
	while(thisCopy.length > 0) {
	    // if factors don't match, then terms are unlike.
	    // this is not recursive ... we're calling Factor.isLike(), not Term.isLike()
	    if(!thisCopy.factors[0].isLike(thatCopy.factors[0])) return false;
	    thisCopy.factors.shift();
	    thatCopy.factors.shift();
	}
	// We have now checked every factor in thisCopy and found matching factors in thatCopy.
	// We finally check if there are any unmatched factors left in thatCopy.
	// If not, terms are like.
	return thatCopy.length==0;
    }
    // extract the coefficient as a {numerator, denominator} object
    // We don't use class Rational because numerator and denominator are both of class Decimal
    get signedCoefficient() {
	var nf,num,den;
	nf = this.collectFactors().numericFactors;
	num=new Decimal(1);
	den=new Decimal(1);
	nf.forEach( function(el) {
	    if(el.index.item.sign>0) 
		num = num.multiply(el.factor.item.pow(el.index.item));
	    else
		den = den.multiply(el.factor.item.pow(el.index.item.negate()));
	});
	return({numerator:num, denominator:den});
    }
    get coefficient() {
	var coeff = this.signedCoefficient;
	if(this.collectFactors().sign<0) coeff.numerator = coeff.numerator.negate();
	return coeff;
    }
    // copy this and return it with a new coefficient
    setCoefficient(num,den) {
	var t=this.clone();
	// strip existing numeric factors
	var factors = t.nonNumericFactors;
	// set the sign
	t.sign=num.sign;
	// and make the numerator positive
	num=num.abs();
	if(!den === undefined && den.sign<0) {
	    t.sign*=-1;
	    den=den.abs();
	}
	// add in the new numeric factors
	factors.unshift(new Factor(num));
	if(!(den === undefined || den.isUnity)) // divide by the denominator
	    factors.unshift(new Factor(den,Factor.NEGATIVE_UNITY));
	t.factors = factors;
	return t;
    }
    // add the coefficient of (other) to that of this (for combining like terms)
    // and return the term with the new coefficient
    addCoefficients(other) {
	var thisCoeff=this.coefficient;
	var thatCoeff=other.coefficient;
	var den=thisCoeff.denominator;
	// new denominator is the product of the two denominators
	if(! thisCoeff.denominator.isEqual(thatCoeff.denominator)) den=den.multiply(thatCoeff.denominator);
	// if both denominators are integers, produce a new denominator that is the LCM of the two
	if(thisCoeff.denominator.isInteger && thatCoeff.denominator.isInteger)
	    den=den.divide(new Decimal(gcd(thisCoeff.denominator.numerator,thatCoeff.denominator.numerator)));
	var num=thisCoeff.numerator.multiply(den).divide(thisCoeff.denominator).add(
	    thatCoeff.numerator.multiply(den).divide(thatCoeff.denominator));
	if(num.isInteger && den.isInteger) {
	    var cf=new Decimal(gcd(num.numerator,den.numerator));
	    num=num.divide(cf);
	    den=den.divide(cf);
	}
	return this.setCoefficient(num,den);
    }
    // test for a zero coefficient
    get isZero() {
	return this.coefficient.numerator == 0;
    }
    get isUnity() {
	var coeff = this.coefficient;
	return coeff.numerator == 1 && coeff.denominator == 1;
    }
    reciprocal() {
	var cpy = this.clone();
	cpy.factors.forEach(function(el,idx,ary) {
	    if(el.factor.isPronumeral || el.factor.isFunction)
		el.index.item = new Expression(new Term(new Factor(el.index.item)));
	    el.index.item = el.index.item.negate();
	});
	return cpy;
    }
}

// ========================================
// Class Expression
//
// An expression is a collection of terms
//
// ========================================

class Expression {
    constructor(t) {
	if(t === undefined) {
	    this.terms=[];
	} else if(t instanceof Expression) {
    	    this.terms = [];
    	    t.terms.forEach( function(item) { 
		this.terms.push(item.clone());
    	    }, this );
	} else {
    	    if(Array.isArray(t)) {
		this.terms=t;
    	    } else {
		this.terms=[t];
    	    }
	}
    }
    clone() {
    	return new Expression(this);
    }
    add(t) {
	var cpy = this.clone();
	if(t instanceof Term) {
	    cpy.terms.push(t);
	}
	else if(t instanceof Expression) {
	    cpy.terms=cpy.terms.concat(t.terms);
	}
	return cpy;
    }
    negate() {
	var t = new Expression();
	this.terms.forEach(function(el, idx){ t.terms[idx]=el.negate(); });
	return t;
    }
    substitute(subs) {
	var t = new Expression();
	this.terms.forEach(function(el, idx){ t.terms[idx]=el.substitute(subs); });
	return t;
    }
    toString() {
	var s = "";
	this.terms.forEach( function(item) {
    	    if(s>"" && item.sign==1) s+="+";
            if(item !==undefined) {
		if(item.toString) 
    		    s+= item.toString(); 
		else
    		    s+="+<"+item.constructor.name+">";
            } else {
		throw new Error("Expression has undefined term");
            }
	} );
	if(s==="") s="0";
	return s;
    }
    toLaTeX() {
	var s = "";
	this.terms.forEach( function(item) {
    	    if(s>"" && item.sign==1) s+="+";
            if(item !==undefined) {
		if(item.toLaTeX) 
    		    s+= item.toLaTeX(); 
		else
    		    s+="+<"+item.constructor.name+">";
            } else {
		throw new Error("Expression has undefined term");
            }
	} );
	if(s==="") s="0";
	return s;
    }
    toMathML() {
	var pre="";
	var s = "";
	this.terms.forEach( function(item, idx, ary) {
    	    if(idx>0 && item.sign>=0) 
		s+="<mo>+</mo>"+item.toMathML();
	    else if(idx>0 && item.sign<0)
		s+="<mo>-</mo>"+item.toMathML();
            else // if(idx==0)
    		s+= item.toMathML(); 
	} );
	if(s==="") s="<mn>0</mn>";
	return "<mrow>"+s+"</mrow>";
    }
    collectFactors() {
	var cpy = new Expression();
	this.terms.forEach( function(el,i,a) {
	    cpy.terms[i]=el.collectFactors();
	} );
	return cpy;
    }
    sortFactors() {
	var cpy = new Expression();
	this.terms.forEach( function(el,i,a) {
	    cpy.terms[i]=el.sortFactors();
	} );
	return cpy;
    }
    get someTermsHaveRepeatedFactors() {
	return this.terms.some( function(el) { return el.hasRepeatedFactors; } );
    }
    // multiply() multiplies out each term of the expression: pre x term x post
    multiply(preTerm, postTerm) {
	var cpy = this.clone()
	this.terms.forEach( function(el, idx, ary) {
	    var product;
	    if(preTerm!==undefined) product = preTerm.multiply(el);
	    else product = el;
	    if(postTerm!==undefined) product = product.multiply(postTerm);
	    cpy.terms[idx] = product;
	});
	return cpy;
    }
    // product treats the exprssion as a single entity and creates a single term expression from the product
    product(expr) {
	// avoid unnecessary brackets:
	var thisTerm = this.length==1?(this.terms[0]):(new Term(new Factor(this)));
	var thatTerm = expr.length==1?(expr.terms[0]):(new Term(new Factor(expr)));
	return new Expression(thisTerm.multiply(thatTerm));
    }
    // unwrap any terms containing unnecessary brackets
    unwrap() {
	return new Expression(this.terms.reduce(function(sum,el){
//	    if(el===NaN) colsole.log("whoops!");
//	    else console.log(el);
	    sum.push(el.unwrap());
	    return sum;
	},[]));
    }
    // return a new expression made up of the expanded terms of this
    expand() {
	return this.unwrap().terms.reduce( function(exp, el) {
	    var expr = el.expand();
	    if(expr)  { // replace the term with the expanded expression
		if(el.sign<0) expr = expr.negate();
		exp=exp.add(expr);
	    } else
		exp=exp.add(el);
	    return exp;
	}, new Expression());
    }
    // keep expanding until no term has an Expression factor
    expandAll() {
	var expanded = this;
	while(expanded.terms.some(function(el) { return el.hasExpressionFactor; })) {
	    expanded = expanded.expand();
	}
	return expanded;
    }
    // collectTerms -- collect like terms.
    // Any terms that end up with zero coefficient get deleted.
    // As part of the collection process, terms are simplified but not expanded
    collectTerms() {
	var cpy = this.clone(); // no need for collectFactors().sortFactors() since isLike does that anyway
	var collected = cpy.terms.reduce(function(sum, current){
	    var i = sum.terms.findIndex(function(el){
		return el.isLike(current);
	    });
	    if(i<0) return sum.add(current);
	    else {
		sum.terms[i]=sum.terms[i].addCoefficients(current);
		if(sum.terms[i].isZero) {
		    sum.terms = sum.terms.slice(0,i).concat(sum.terms.slice(i+1,sum.length));
		}
		return sum;
	    }
	}, new Expression());
	return collected;
    }
    // hasUncollectedTerms -- the expression has terms that could be collected
    get hasUncollectedTerms() {
	var cpy = this.collectTerms();
	return this.length != cpy.length;
    }
    // tests two expressions for equality by collecting like terms 
    isEqual(other) {
	var diff = this.collectTerms().negate().add(other).collectTerms();
	return diff.length==0;
    }
    // an expression is simple if each term is simple, and there are no like term pairs
    // (does not have to be expanded)
    get isSimple() {
	return !(this.hasUncollectedTerms||this.someTermsHaveRepeatedFactors|| this.hasNegativeCoefficients);    
    }
    get isSimpleAndExpanded() {
	return !this.hasUncollectedTerms && ! this.hasNegativeCoefficients &&
	    this.terms.every(function(el){ return el.isSimple; });
    }
    get length() {
	return this.terms.length;
    }
    // if any coefficient other than the first is negative we will end up with things like x+-5 or 3--2x
    // In many situations this is considered unsimplified
    get hasNegativeCoefficients() {
	return this.terms.some(function(el,idx){
//	    console.log("idx="+idx+" numerator="+el.coefficient.numerator+"; return "+(idx>0 && el.signedCoefficient.numerator<0));
	    return idx>0 && el.signedCoefficient.numerator.sign<0;
	});
    }
}


